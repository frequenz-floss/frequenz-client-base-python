{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Client Base Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Utilities for writing Frequenz API clients</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Client Base Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>base<ul> <li>conversion</li> <li>retry</li> <li>streaming</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/base/","title":"Index","text":""},{"location":"reference/frequenz/client/base/#frequenz.client.base","title":"frequenz.client.base","text":"<p>Utilities for writing Frequenz API clients.</p>"},{"location":"reference/frequenz/client/base/conversion/","title":"conversion","text":""},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion","title":"frequenz.client.base.conversion","text":"<p>Helper functions to convert to/from common python types.</p>"},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion.to_datetime","title":"frequenz.client.base.conversion.to_datetime","text":"<pre><code>to_datetime(\n    ts: Timestamp, tz: timezone = timezone.utc\n) -&gt; datetime\n</code></pre> <p>Convert a protobuf Timestamp to a datetime.</p> PARAMETER  DESCRIPTION <code>ts</code> <p>Timestamp object to convert</p> <p> TYPE: <code>Timestamp</code> </p> <code>tz</code> <p>Timezone to use for the datetime</p> <p> TYPE: <code>timezone</code> DEFAULT: <code>utc</code> </p> RETURNS DESCRIPTION <code>datetime</code> <p>Timestamp converted to datetime</p> Source code in <code>frequenz/client/base/conversion.py</code> <pre><code>def to_datetime(ts: Timestamp, tz: timezone = timezone.utc) -&gt; datetime:\n    \"\"\"Convert a protobuf Timestamp to a datetime.\n\n    Args:\n        ts: Timestamp object to convert\n        tz: Timezone to use for the datetime\n\n    Returns:\n        Timestamp converted to datetime\n    \"\"\"\n    # Add microseconds and add nanoseconds converted to microseconds\n    microseconds = int(ts.nanos / 1000)\n    return datetime.fromtimestamp(ts.seconds + microseconds * 1e-6, tz=tz)\n</code></pre>"},{"location":"reference/frequenz/client/base/conversion/#frequenz.client.base.conversion.to_timestamp","title":"frequenz.client.base.conversion.to_timestamp","text":"<pre><code>to_timestamp(dt: datetime | None) -&gt; Timestamp | None\n</code></pre> <p>Convert a datetime to a protobuf Timestamp.</p> <p>Returns None if dt is None.</p> PARAMETER  DESCRIPTION <code>dt</code> <p>datetime object to convert</p> <p> TYPE: <code>datetime | None</code> </p> RETURNS DESCRIPTION <code>Timestamp | None</code> <p>datetime converted to Timestamp</p> Source code in <code>frequenz/client/base/conversion.py</code> <pre><code>def to_timestamp(dt: datetime | None) -&gt; Timestamp | None:\n    \"\"\"Convert a datetime to a protobuf Timestamp.\n\n    Returns None if dt is None.\n\n    Args:\n        dt: datetime object to convert\n\n    Returns:\n        datetime converted to Timestamp\n    \"\"\"\n    if dt is None:\n        return None\n\n    ts = Timestamp()\n    ts.FromDatetime(dt)\n    return ts\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/","title":"retry","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry","title":"frequenz.client.base.retry","text":"<p>Implementations for retry strategies.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.DEFAULT_RETRY_INTERVAL","title":"frequenz.client.base.retry.DEFAULT_RETRY_INTERVAL  <code>module-attribute</code>","text":"<pre><code>DEFAULT_RETRY_INTERVAL = 3.0\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.DEFAULT_RETRY_JITTER","title":"frequenz.client.base.retry.DEFAULT_RETRY_JITTER  <code>module-attribute</code>","text":"<pre><code>DEFAULT_RETRY_JITTER = 1.0\n</code></pre> <p>Default retry jitter, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff","title":"frequenz.client.base.retry.ExponentialBackoff","text":"<p>             Bases: <code>Strategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>class ExponentialBackoff(Strategy):\n    \"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\n\n    DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n    \"\"\"Default retry interval, in seconds.\"\"\"\n\n    DEFAULT_MAX_INTERVAL = 60.0\n    \"\"\"Default maximum retry interval, in seconds.\"\"\"\n\n    DEFAULT_MULTIPLIER = 2.0\n    \"\"\"Default multiplier for exponential increment.\"\"\"\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        initial_interval: float = DEFAULT_INTERVAL,\n        max_interval: float = DEFAULT_MAX_INTERVAL,\n        multiplier: float = DEFAULT_MULTIPLIER,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: int | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `ExponentialBackoff` instance.\n\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._initial = initial_interval\n        self._max = max_interval\n        self._multiplier = multiplier\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n        return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.DEFAULT_INTERVAL","title":"DEFAULT_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.DEFAULT_MAX_INTERVAL","title":"DEFAULT_MAX_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MAX_INTERVAL = 60.0\n</code></pre> <p>Default maximum retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.DEFAULT_MULTIPLIER","title":"DEFAULT_MULTIPLIER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MULTIPLIER = 2.0\n</code></pre> <p>Default multiplier for exponential increment.</p>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __init__(\n    self,\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None:\n    \"\"\"Create a `ExponentialBackoff` instance.\n\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._initial = initial_interval\n    self._max = max_interval\n    self._multiplier = multiplier\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>Self</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n    return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.ExponentialBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff","title":"frequenz.client.base.retry.LinearBackoff","text":"<p>             Bases: <code>Strategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>class LinearBackoff(Strategy):\n    \"\"\"Provides methods for calculating the interval between retries.\"\"\"\n\n    def __init__(\n        self,\n        interval: float = DEFAULT_RETRY_INTERVAL,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: int | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `LinearBackoff` instance.\n\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._interval = interval\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __init__(\n    self,\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None:\n    \"\"\"Create a `LinearBackoff` instance.\n\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._interval = interval\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>Self</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.LinearBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy","title":"frequenz.client.base.retry.Strategy","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>class Strategy(ABC):\n    \"\"\"Interface for implementing retry strategies.\"\"\"\n\n    _limit: int | None\n    _count: int\n\n    @abstractmethod\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n\n    def get_progress(self) -&gt; str:\n        \"\"\"Return a string denoting the retry progress.\n\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\n        if self._limit is None:\n            return f\"({self._count}/\u221e)\"\n\n        return f\"({self._count}/{self._limit})\"\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the retry counter.\n\n        To be called as soon as a connection is successful.\n        \"\"\"\n        self._count = 0\n\n    def copy(self) -&gt; Self:\n        \"\"\"Create a new instance of `self`.\n\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\n        ret = deepcopy(self)\n        ret.reset()\n        return ret\n\n    def __iter__(self) -&gt; Iterator[float]:\n        \"\"\"Return an iterator over the retry intervals.\n\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\n        while True:\n            interval = self.next_interval()\n            if interval is None:\n                break\n            yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>Self</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.next_interval","title":"next_interval  <code>abstractmethod</code>","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry/#frequenz.client.base.retry.Strategy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/","title":"streaming","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming","title":"frequenz.client.base.streaming","text":"<p>Implementation of the grpc streaming helper.</p>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.InputT","title":"frequenz.client.base.streaming.InputT  <code>module-attribute</code>","text":"<pre><code>InputT = TypeVar('InputT')\n</code></pre> <p>The input type of the stream.</p>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.OutputT","title":"frequenz.client.base.streaming.OutputT  <code>module-attribute</code>","text":"<pre><code>OutputT = TypeVar('OutputT')\n</code></pre> <p>The output type of the stream.</p>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster","title":"frequenz.client.base.streaming.GrpcStreamBroadcaster","text":"<p>             Bases: <code>Generic[InputT, OutputT]</code></p> <p>Helper class to handle grpc streaming methods.</p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>class GrpcStreamBroadcaster(Generic[InputT, OutputT]):\n    \"\"\"Helper class to handle grpc streaming methods.\"\"\"\n\n    def __init__(\n        self,\n        stream_name: str,\n        stream_method: Callable[[], grpc.aio.UnaryStreamCall[Any, InputT]],\n        transform: Callable[[InputT], OutputT],\n        retry_strategy: retry.Strategy | None = None,\n    ):\n        \"\"\"Initialize the streaming helper.\n\n        Args:\n            stream_name: A name to identify the stream in the logs.\n            stream_method: A function that returns the grpc stream. This function is\n                called everytime the connection is lost and we want to retry.\n            transform: A function to transform the input type to the output type.\n            retry_strategy: The retry strategy to use, when the connection is lost. Defaults\n                to retries every 3 seconds, with a jitter of 1 second, indefinitely.\n        \"\"\"\n        self._stream_name = stream_name\n        self._stream_method = stream_method\n        self._transform = transform\n        self._retry_strategy = (\n            retry.LinearBackoff() if retry_strategy is None else retry_strategy.copy()\n        )\n\n        self._channel: channels.Broadcast[OutputT] = channels.Broadcast(\n            name=f\"GrpcStreamBroadcaster-{stream_name}\"\n        )\n        self._task = asyncio.create_task(self._run())\n\n    def new_receiver(self, maxsize: int = 50) -&gt; channels.Receiver[OutputT]:\n        \"\"\"Create a new receiver for the stream.\n\n        Args:\n            maxsize: The maximum number of messages to buffer.\n\n        Returns:\n            A new receiver.\n        \"\"\"\n        return self._channel.new_receiver(limit=maxsize)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the streaming helper.\"\"\"\n        if self._task.done():\n            return\n        self._task.cancel()\n        try:\n            await self._task\n        except asyncio.CancelledError:\n            pass\n        await self._channel.close()\n\n    async def _run(self) -&gt; None:\n        \"\"\"Run the streaming helper.\"\"\"\n        sender = self._channel.new_sender()\n\n        while True:\n            _logger.debug(\"Making call to grpc streaming method: %s\", self._stream_name)\n\n            try:\n                call = self._stream_method()\n                async for msg in call:\n                    await sender.send(self._transform(msg))\n            except grpc.aio.AioRpcError:\n                _logger.exception(\n                    \"Error in grpc streaming method: %s\", self._stream_name\n                )\n            if interval := self._retry_strategy.next_interval():\n                _logger.warning(\n                    \"`%s`, connection ended, retrying %s in %0.3f seconds.\",\n                    self._stream_name,\n                    self._retry_strategy.get_progress(),\n                    interval,\n                )\n                await asyncio.sleep(interval)\n            else:\n                _logger.warning(\n                    \"`%s`, connection ended, retry limit exceeded %s.\",\n                    self._stream_name,\n                    self._retry_strategy.get_progress(),\n                )\n                await self._channel.close()\n                break\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster.__init__","title":"__init__","text":"<pre><code>__init__(\n    stream_name: str,\n    stream_method: Callable[\n        [], UnaryStreamCall[Any, InputT]\n    ],\n    transform: Callable[[InputT], OutputT],\n    retry_strategy: Strategy | None = None,\n)\n</code></pre> <p>Initialize the streaming helper.</p> PARAMETER  DESCRIPTION <code>stream_name</code> <p>A name to identify the stream in the logs.</p> <p> TYPE: <code>str</code> </p> <code>stream_method</code> <p>A function that returns the grpc stream. This function is called everytime the connection is lost and we want to retry.</p> <p> TYPE: <code>Callable[[], UnaryStreamCall[Any, InputT]]</code> </p> <code>transform</code> <p>A function to transform the input type to the output type.</p> <p> TYPE: <code>Callable[[InputT], OutputT]</code> </p> <code>retry_strategy</code> <p>The retry strategy to use, when the connection is lost. Defaults to retries every 3 seconds, with a jitter of 1 second, indefinitely.</p> <p> TYPE: <code>Strategy | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>def __init__(\n    self,\n    stream_name: str,\n    stream_method: Callable[[], grpc.aio.UnaryStreamCall[Any, InputT]],\n    transform: Callable[[InputT], OutputT],\n    retry_strategy: retry.Strategy | None = None,\n):\n    \"\"\"Initialize the streaming helper.\n\n    Args:\n        stream_name: A name to identify the stream in the logs.\n        stream_method: A function that returns the grpc stream. This function is\n            called everytime the connection is lost and we want to retry.\n        transform: A function to transform the input type to the output type.\n        retry_strategy: The retry strategy to use, when the connection is lost. Defaults\n            to retries every 3 seconds, with a jitter of 1 second, indefinitely.\n    \"\"\"\n    self._stream_name = stream_name\n    self._stream_method = stream_method\n    self._transform = transform\n    self._retry_strategy = (\n        retry.LinearBackoff() if retry_strategy is None else retry_strategy.copy()\n    )\n\n    self._channel: channels.Broadcast[OutputT] = channels.Broadcast(\n        name=f\"GrpcStreamBroadcaster-{stream_name}\"\n    )\n    self._task = asyncio.create_task(self._run())\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(maxsize: int = 50) -&gt; Receiver[OutputT]\n</code></pre> <p>Create a new receiver for the stream.</p> PARAMETER  DESCRIPTION <code>maxsize</code> <p>The maximum number of messages to buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[OutputT]</code> <p>A new receiver.</p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>def new_receiver(self, maxsize: int = 50) -&gt; channels.Receiver[OutputT]:\n    \"\"\"Create a new receiver for the stream.\n\n    Args:\n        maxsize: The maximum number of messages to buffer.\n\n    Returns:\n        A new receiver.\n    \"\"\"\n    return self._channel.new_receiver(limit=maxsize)\n</code></pre>"},{"location":"reference/frequenz/client/base/streaming/#frequenz.client.base.streaming.GrpcStreamBroadcaster.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the streaming helper.</p> Source code in <code>frequenz/client/base/streaming.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the streaming helper.\"\"\"\n    if self._task.done():\n        return\n    self._task.cancel()\n    try:\n        await self._task\n    except asyncio.CancelledError:\n        pass\n    await self._channel.close()\n</code></pre>"}]}